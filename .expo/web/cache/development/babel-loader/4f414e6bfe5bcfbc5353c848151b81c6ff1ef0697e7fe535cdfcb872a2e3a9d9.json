{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { calculatePosition } from './calculatePosition';\nimport { useCallback, useRef, useState } from 'react';\nimport { useCloseOnScroll } from './useCloseOnScroll';\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\nvar visualViewport = typeof window !== 'undefined' && window.visualViewport;\nexport function useOverlayPosition(props) {\n  var _targetRef$current, _targetRef$current2;\n  var direction = isRTL() ? 'rtl' : undefined;\n  var targetRef = props.targetRef,\n    overlayRef = props.overlayRef,\n    _props$scrollRef = props.scrollRef,\n    scrollRef = _props$scrollRef === void 0 ? overlayRef : _props$scrollRef,\n    _props$placement = props.placement,\n    placement = _props$placement === void 0 ? 'bottom' : _props$placement,\n    _props$containerPaddi = props.containerPadding,\n    containerPadding = _props$containerPaddi === void 0 ? 12 : _props$containerPaddi,\n    _props$shouldFlip = props.shouldFlip,\n    shouldFlip = _props$shouldFlip === void 0 ? true : _props$shouldFlip,\n    _props$boundaryElemen = props.boundaryElement,\n    boundaryElement = _props$boundaryElemen === void 0 ? typeof document !== 'undefined' ? document.body : null : _props$boundaryElemen,\n    _props$offset = props.offset,\n    offset = _props$offset === void 0 ? 0 : _props$offset,\n    _props$crossOffset = props.crossOffset,\n    crossOffset = _props$crossOffset === void 0 ? 0 : _props$crossOffset,\n    _props$shouldUpdatePo = props.shouldUpdatePosition,\n    shouldUpdatePosition = _props$shouldUpdatePo === void 0 ? true : _props$shouldUpdatePo,\n    _props$isOpen = props.isOpen,\n    isOpen = _props$isOpen === void 0 ? true : _props$isOpen,\n    _props$shouldOverlapW = props.shouldOverlapWithTrigger,\n    shouldOverlapWithTrigger = _props$shouldOverlapW === void 0 ? false : _props$shouldOverlapW,\n    onClose = props.onClose;\n  var _useState = useState({\n      position: {},\n      arrowOffsetLeft: undefined,\n      arrowOffsetTop: undefined,\n      maxHeight: undefined,\n      placement: undefined\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    position = _useState2[0],\n    setPosition = _useState2[1];\n  var deps = [shouldUpdatePosition, placement, overlayRef.current, (_targetRef$current = targetRef.current) === null || _targetRef$current === void 0 ? void 0 : _targetRef$current.offsetLeft, (_targetRef$current2 = targetRef.current) === null || _targetRef$current2 === void 0 ? void 0 : _targetRef$current2.offsetTop, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, shouldOverlapWithTrigger];\n  var updatePosition = useCallback(function () {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {\n      return;\n    }\n    setPosition(calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip: shouldFlip,\n      boundaryElement: boundaryElement,\n      offset: offset,\n      crossOffset: crossOffset,\n      shouldOverlapWithTrigger: shouldOverlapWithTrigger\n    }));\n  }, deps);\n  useLayoutEffect(updatePosition, deps);\n  useResize(updatePosition);\n  var isResizing = useRef(false);\n  useLayoutEffect(function () {\n    var timeout;\n    var onResize = function onResize() {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(function () {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n    visualViewport === null || visualViewport === void 0 || visualViewport.addEventListener('resize', onResize);\n    return function () {\n      visualViewport === null || visualViewport === void 0 || visualViewport.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n  var close = useCallback(function () {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen: isOpen,\n    onClose: onClose ? close : undefined\n  });\n  return {\n    rendered: true,\n    overlayProps: {\n      style: _objectSpread(_objectSpread({\n        position: 'absolute',\n        zIndex: 100000\n      }, position.position), {}, {\n        maxHeight: position.maxHeight\n      })\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition: updatePosition\n  };\n}\nfunction useResize(onResize) {\n  useLayoutEffect(function () {\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}","map":{"version":3,"names":["calculatePosition","useCallback","useRef","useState","useCloseOnScroll","isRTL","useLayoutEffect","visualViewport","window","useOverlayPosition","props","_targetRef$current","_targetRef$current2","direction","undefined","targetRef","overlayRef","_props$scrollRef","scrollRef","_props$placement","placement","_props$containerPaddi","containerPadding","_props$shouldFlip","shouldFlip","_props$boundaryElemen","boundaryElement","document","body","_props$offset","offset","_props$crossOffset","crossOffset","_props$shouldUpdatePo","shouldUpdatePosition","_props$isOpen","isOpen","_props$shouldOverlapW","shouldOverlapWithTrigger","onClose","_useState","position","arrowOffsetLeft","arrowOffsetTop","maxHeight","_useState2","_slicedToArray","setPosition","deps","current","offsetLeft","offsetTop","updatePosition","translateRTL","overlayNode","targetNode","scrollNode","padding","useResize","isResizing","timeout","onResize","clearTimeout","setTimeout","addEventListener","removeEventListener","close","triggerRef","rendered","overlayProps","style","_objectSpread","zIndex","arrowProps","left","top","replace"],"sources":["C:\\JsonMobile\\frontend\\node_modules\\@react-native-aria\\overlays\\src\\web\\overlays\\src\\useOverlayPosition.ts"],"sourcesContent":["//@ts-nocheck\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n\r\nimport { calculatePosition, PositionResult } from './calculatePosition';\r\nimport {\r\n  HTMLAttributes,\r\n  RefObject,\r\n  useCallback,\r\n  useRef,\r\n  useState,\r\n} from 'react';\r\nimport { Placement, PlacementAxis, PositionProps } from '@react-types/overlays';\r\nimport { useCloseOnScroll } from './useCloseOnScroll';\r\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\r\n\r\ninterface AriaPositionProps extends PositionProps {\r\n  /**\r\n   * Element that that serves as the positioning boundary.\r\n   * @default document.body\r\n   */\r\n  boundaryElement?: HTMLElement;\r\n  /**\r\n   * The ref for the element which the overlay positions itself with respect to.\r\n   */\r\n  targetRef: RefObject<HTMLElement>;\r\n  /**\r\n   * The ref for the overlay element.\r\n   */\r\n  overlayRef: RefObject<HTMLElement>;\r\n  /**\r\n   * A ref for the scrollable region within the overlay.\r\n   * @default overlayRef\r\n   */\r\n  scrollRef?: RefObject<HTMLElement>;\r\n  /**\r\n   * Whether the overlay should update its position automatically.\r\n   * @default true\r\n   */\r\n  shouldUpdatePosition?: boolean;\r\n  /** Handler that is called when the overlay should close. */\r\n  onClose?: () => void;\r\n  /** Determines whether the overlay should overlap with the trigger */\r\n  shouldOverlapWithTrigger?: boolean;\r\n}\r\n\r\ninterface PositionAria {\r\n  /** Props for the overlay container element. */\r\n  overlayProps: HTMLAttributes<Element>;\r\n  /** Props for the overlay tip arrow if any. */\r\n  arrowProps: HTMLAttributes<Element>;\r\n  /** Placement of the overlay with respect to the overlay trigger. */\r\n  placement: PlacementAxis;\r\n  /** Updates the position of the overlay. */\r\n  updatePosition(): void;\r\n}\r\n\r\n// @ts-ignore\r\nlet visualViewport = typeof window !== 'undefined' && window.visualViewport;\r\n\r\n/**\r\n * Handles positioning overlays like popovers and menus relative to a trigger\r\n * element, and updating the position when the window resizes.\r\n */\r\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\r\n  const direction = isRTL() ? 'rtl' : undefined;\r\n  let {\r\n    targetRef,\r\n    overlayRef,\r\n    scrollRef = overlayRef,\r\n    placement = 'bottom' as Placement,\r\n    containerPadding = 12,\r\n    shouldFlip = true,\r\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\r\n    offset = 0,\r\n    crossOffset = 0,\r\n    shouldUpdatePosition = true,\r\n    isOpen = true,\r\n    shouldOverlapWithTrigger = false,\r\n    onClose,\r\n  } = props;\r\n  let [position, setPosition] = useState<PositionResult>({\r\n    position: {},\r\n    arrowOffsetLeft: undefined,\r\n    arrowOffsetTop: undefined,\r\n    maxHeight: undefined,\r\n    placement: undefined,\r\n  });\r\n\r\n  let deps = [\r\n    shouldUpdatePosition,\r\n    placement,\r\n    overlayRef.current,\r\n    targetRef.current?.offsetLeft,\r\n    targetRef.current?.offsetTop,\r\n    scrollRef.current,\r\n    containerPadding,\r\n    shouldFlip,\r\n    boundaryElement,\r\n    offset,\r\n    crossOffset,\r\n    isOpen,\r\n    direction,\r\n    shouldOverlapWithTrigger,\r\n  ];\r\n\r\n  let updatePosition = useCallback(() => {\r\n    if (\r\n      shouldUpdatePosition === false ||\r\n      !isOpen ||\r\n      !overlayRef.current ||\r\n      !targetRef.current ||\r\n      !scrollRef.current ||\r\n      !boundaryElement\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    setPosition(\r\n      calculatePosition({\r\n        placement: translateRTL(placement, direction),\r\n        overlayNode: overlayRef.current,\r\n        targetNode: targetRef.current,\r\n        scrollNode: scrollRef.current,\r\n        padding: containerPadding,\r\n        shouldFlip,\r\n        boundaryElement,\r\n        offset,\r\n        crossOffset,\r\n        shouldOverlapWithTrigger,\r\n      })\r\n    );\r\n  }, deps);\r\n\r\n  // Update position when anything changes\r\n  useLayoutEffect(updatePosition, deps);\r\n\r\n  // Update position on window resize\r\n  useResize(updatePosition);\r\n\r\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\r\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\r\n  let isResizing = useRef(false);\r\n  useLayoutEffect(() => {\r\n    let timeout: NodeJS.Timeout;\r\n    let onResize = () => {\r\n      isResizing.current = true;\r\n      clearTimeout(timeout);\r\n\r\n      timeout = setTimeout(() => {\r\n        isResizing.current = false;\r\n      }, 500);\r\n\r\n      updatePosition();\r\n    };\r\n\r\n    visualViewport?.addEventListener('resize', onResize);\r\n\r\n    return () => {\r\n      visualViewport?.removeEventListener('resize', onResize);\r\n    };\r\n  }, [updatePosition]);\r\n\r\n  let close = useCallback(() => {\r\n    if (!isResizing.current) {\r\n      onClose();\r\n    }\r\n  }, [onClose, isResizing]);\r\n\r\n  // When scrolling a parent scrollable region of the trigger (other than the body),\r\n  // we hide the popover. Otherwise, its position would be incorrect.\r\n  useCloseOnScroll({\r\n    triggerRef: targetRef,\r\n    isOpen,\r\n    onClose: onClose ? close : undefined,\r\n  });\r\n\r\n  // useLayoutEffect(() => {\r\n  //   const mutationObserver = new MutationObserver((mutations) => {\r\n  //     updatePosition();\r\n  //     mutations.forEach((mutation) => {\r\n  //       // if (mutation.attributeName === 'style') {\r\n  //       //   const transform = mutation.target.style.transform;\r\n  //       //   if (transform) {\r\n  //       //     const match = transform.match(/scale\\((.+)\\)/);\r\n  //       //     if (match) {\r\n  //       //       const scale = parseFloat(match[1]);\r\n  //       //       console.log(`Scale: ${scale}`);\r\n  //       //       // updatePosition();\r\n  //       //     }\r\n  //       //   }\r\n  //       // }\r\n  //     });\r\n  //   });\r\n\r\n  //   mutationObserver.observe(overlayRef?.current, { attributes: true });\r\n\r\n  //   return () => mutationObserver.disconnect();\r\n  // }, [overlayRef, updatePosition]);\r\n\r\n  return {\r\n    rendered: true,\r\n    overlayProps: {\r\n      style: {\r\n        position: 'absolute',\r\n        zIndex: 100000, // should match the z-index in ModalTrigger\r\n        ...position.position,\r\n        maxHeight: position.maxHeight,\r\n      },\r\n    },\r\n    placement: position.placement,\r\n    arrowProps: {\r\n      style: {\r\n        left: position.arrowOffsetLeft,\r\n        top: position.arrowOffsetTop,\r\n      },\r\n    },\r\n    updatePosition,\r\n  };\r\n}\r\n\r\nfunction useResize(onResize) {\r\n  useLayoutEffect(() => {\r\n    window.addEventListener('resize', onResize, false);\r\n    return () => {\r\n      window.removeEventListener('resize', onResize, false);\r\n    };\r\n  }, [onResize]);\r\n}\r\n\r\nfunction translateRTL(position, direction) {\r\n  if (direction === 'rtl') {\r\n    return position.replace('start', 'right').replace('end', 'left');\r\n  }\r\n  return position.replace('start', 'left').replace('end', 'right');\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}