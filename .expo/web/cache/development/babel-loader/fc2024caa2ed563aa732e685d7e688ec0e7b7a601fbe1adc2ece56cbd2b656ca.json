{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar Declaration = require('./declaration');\nvar tokenizer = require('./tokenize');\nvar Comment = require('./comment');\nvar AtRule = require('./at-rule');\nvar Root = require('./root');\nvar Rule = require('./rule');\nvar SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n};\nfunction findLastWithPosition(tokens) {\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    var pos = token[3] || token[2];\n    if (pos) return pos;\n  }\n}\nvar Parser = function () {\n  function Parser(input) {\n    _classCallCheck(this, Parser);\n    this.input = input;\n    this.root = new Root();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.customProperty = false;\n    this.createTokenizer();\n    this.root.source = {\n      input: input,\n      start: {\n        column: 1,\n        line: 1,\n        offset: 0\n      }\n    };\n  }\n  _createClass(Parser, [{\n    key: \"atrule\",\n    value: function atrule(token) {\n      var node = new AtRule();\n      node.name = token[1].slice(1);\n      if (node.name === '') {\n        this.unnamedAtrule(node, token);\n      }\n      this.init(node, token[2]);\n      var type;\n      var prev;\n      var shift;\n      var last = false;\n      var open = false;\n      var params = [];\n      var brackets = [];\n      while (!this.tokenizer.endOfFile()) {\n        token = this.tokenizer.nextToken();\n        type = token[0];\n        if (type === '(' || type === '[') {\n          brackets.push(type === '(' ? ')' : ']');\n        } else if (type === '{' && brackets.length > 0) {\n          brackets.push('}');\n        } else if (type === brackets[brackets.length - 1]) {\n          brackets.pop();\n        }\n        if (brackets.length === 0) {\n          if (type === ';') {\n            node.source.end = this.getPosition(token[2]);\n            node.source.end.offset++;\n            this.semicolon = true;\n            break;\n          } else if (type === '{') {\n            open = true;\n            break;\n          } else if (type === '}') {\n            if (params.length > 0) {\n              shift = params.length - 1;\n              prev = params[shift];\n              while (prev && prev[0] === 'space') {\n                prev = params[--shift];\n              }\n              if (prev) {\n                node.source.end = this.getPosition(prev[3] || prev[2]);\n                node.source.end.offset++;\n              }\n            }\n            this.end(token);\n            break;\n          } else {\n            params.push(token);\n          }\n        } else {\n          params.push(token);\n        }\n        if (this.tokenizer.endOfFile()) {\n          last = true;\n          break;\n        }\n      }\n      node.raws.between = this.spacesAndCommentsFromEnd(params);\n      if (params.length) {\n        node.raws.afterName = this.spacesAndCommentsFromStart(params);\n        this.raw(node, 'params', params);\n        if (last) {\n          token = params[params.length - 1];\n          node.source.end = this.getPosition(token[3] || token[2]);\n          node.source.end.offset++;\n          this.spaces = node.raws.between;\n          node.raws.between = '';\n        }\n      } else {\n        node.raws.afterName = '';\n        node.params = '';\n      }\n      if (open) {\n        node.nodes = [];\n        this.current = node;\n      }\n    }\n  }, {\n    key: \"checkMissedSemicolon\",\n    value: function checkMissedSemicolon(tokens) {\n      var colon = this.colon(tokens);\n      if (colon === false) return;\n      var founded = 0;\n      var token;\n      for (var j = colon - 1; j >= 0; j--) {\n        token = tokens[j];\n        if (token[0] !== 'space') {\n          founded += 1;\n          if (founded === 2) break;\n        }\n      }\n      throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);\n    }\n  }, {\n    key: \"colon\",\n    value: function colon(tokens) {\n      var brackets = 0;\n      var token, type, prev;\n      for (var _ref of tokens.entries()) {\n        var _ref2 = _slicedToArray(_ref, 2);\n        var i = _ref2[0];\n        var element = _ref2[1];\n        token = element;\n        type = token[0];\n        if (type === '(') {\n          brackets += 1;\n        }\n        if (type === ')') {\n          brackets -= 1;\n        }\n        if (brackets === 0 && type === ':') {\n          if (!prev) {\n            this.doubleColon(token);\n          } else if (prev[0] === 'word' && prev[1] === 'progid') {\n            continue;\n          } else {\n            return i;\n          }\n        }\n        prev = token;\n      }\n      return false;\n    }\n  }, {\n    key: \"comment\",\n    value: function comment(token) {\n      var node = new Comment();\n      this.init(node, token[2]);\n      node.source.end = this.getPosition(token[3] || token[2]);\n      node.source.end.offset++;\n      var text = token[1].slice(2, -2);\n      if (/^\\s*$/.test(text)) {\n        node.text = '';\n        node.raws.left = text;\n        node.raws.right = '';\n      } else {\n        var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n        node.text = match[2];\n        node.raws.left = match[1];\n        node.raws.right = match[3];\n      }\n    }\n  }, {\n    key: \"createTokenizer\",\n    value: function createTokenizer() {\n      this.tokenizer = tokenizer(this.input);\n    }\n  }, {\n    key: \"decl\",\n    value: function decl(tokens, customProperty) {\n      var node = new Declaration();\n      this.init(node, tokens[0][2]);\n      var last = tokens[tokens.length - 1];\n      if (last[0] === ';') {\n        this.semicolon = true;\n        tokens.pop();\n      }\n      node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n      node.source.end.offset++;\n      while (tokens[0][0] !== 'word') {\n        if (tokens.length === 1) this.unknownWord(tokens);\n        node.raws.before += tokens.shift()[1];\n      }\n      node.source.start = this.getPosition(tokens[0][2]);\n      node.prop = '';\n      while (tokens.length) {\n        var type = tokens[0][0];\n        if (type === ':' || type === 'space' || type === 'comment') {\n          break;\n        }\n        node.prop += tokens.shift()[1];\n      }\n      node.raws.between = '';\n      var token;\n      while (tokens.length) {\n        token = tokens.shift();\n        if (token[0] === ':') {\n          node.raws.between += token[1];\n          break;\n        } else {\n          if (token[0] === 'word' && /\\w/.test(token[1])) {\n            this.unknownWord([token]);\n          }\n          node.raws.between += token[1];\n        }\n      }\n      if (node.prop[0] === '_' || node.prop[0] === '*') {\n        node.raws.before += node.prop[0];\n        node.prop = node.prop.slice(1);\n      }\n      var firstSpaces = [];\n      var next;\n      while (tokens.length) {\n        next = tokens[0][0];\n        if (next !== 'space' && next !== 'comment') break;\n        firstSpaces.push(tokens.shift());\n      }\n      this.precheckMissedSemicolon(tokens);\n      for (var i = tokens.length - 1; i >= 0; i--) {\n        token = tokens[i];\n        if (token[1].toLowerCase() === '!important') {\n          node.important = true;\n          var string = this.stringFrom(tokens, i);\n          string = this.spacesFromEnd(tokens) + string;\n          if (string !== ' !important') node.raws.important = string;\n          break;\n        } else if (token[1].toLowerCase() === 'important') {\n          var cache = tokens.slice(0);\n          var str = '';\n          for (var j = i; j > 0; j--) {\n            var _type = cache[j][0];\n            if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n              break;\n            }\n            str = cache.pop()[1] + str;\n          }\n          if (str.trim().indexOf('!') === 0) {\n            node.important = true;\n            node.raws.important = str;\n            tokens = cache;\n          }\n        }\n        if (token[0] !== 'space' && token[0] !== 'comment') {\n          break;\n        }\n      }\n      var hasWord = tokens.some(function (i) {\n        return i[0] !== 'space' && i[0] !== 'comment';\n      });\n      if (hasWord) {\n        node.raws.between += firstSpaces.map(function (i) {\n          return i[1];\n        }).join('');\n        firstSpaces = [];\n      }\n      this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);\n      if (node.value.includes(':') && !customProperty) {\n        this.checkMissedSemicolon(tokens);\n      }\n    }\n  }, {\n    key: \"doubleColon\",\n    value: function doubleColon(token) {\n      throw this.input.error('Double colon', {\n        offset: token[2]\n      }, {\n        offset: token[2] + token[1].length\n      });\n    }\n  }, {\n    key: \"emptyRule\",\n    value: function emptyRule(token) {\n      var node = new Rule();\n      this.init(node, token[2]);\n      node.selector = '';\n      node.raws.between = '';\n      this.current = node;\n    }\n  }, {\n    key: \"end\",\n    value: function end(token) {\n      if (this.current.nodes && this.current.nodes.length) {\n        this.current.raws.semicolon = this.semicolon;\n      }\n      this.semicolon = false;\n      this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n      this.spaces = '';\n      if (this.current.parent) {\n        this.current.source.end = this.getPosition(token[2]);\n        this.current.source.end.offset++;\n        this.current = this.current.parent;\n      } else {\n        this.unexpectedClose(token);\n      }\n    }\n  }, {\n    key: \"endFile\",\n    value: function endFile() {\n      if (this.current.parent) this.unclosedBlock();\n      if (this.current.nodes && this.current.nodes.length) {\n        this.current.raws.semicolon = this.semicolon;\n      }\n      this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n      this.root.source.end = this.getPosition(this.tokenizer.position());\n    }\n  }, {\n    key: \"freeSemicolon\",\n    value: function freeSemicolon(token) {\n      this.spaces += token[1];\n      if (this.current.nodes) {\n        var prev = this.current.nodes[this.current.nodes.length - 1];\n        if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n          prev.raws.ownSemicolon = this.spaces;\n          this.spaces = '';\n        }\n      }\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(offset) {\n      var pos = this.input.fromOffset(offset);\n      return {\n        column: pos.col,\n        line: pos.line,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"init\",\n    value: function init(node, offset) {\n      this.current.push(node);\n      node.source = {\n        input: this.input,\n        start: this.getPosition(offset)\n      };\n      node.raws.before = this.spaces;\n      this.spaces = '';\n      if (node.type !== 'comment') this.semicolon = false;\n    }\n  }, {\n    key: \"other\",\n    value: function other(start) {\n      var end = false;\n      var type = null;\n      var colon = false;\n      var bracket = null;\n      var brackets = [];\n      var customProperty = start[1].startsWith('--');\n      var tokens = [];\n      var token = start;\n      while (token) {\n        type = token[0];\n        tokens.push(token);\n        if (type === '(' || type === '[') {\n          if (!bracket) bracket = token;\n          brackets.push(type === '(' ? ')' : ']');\n        } else if (customProperty && colon && type === '{') {\n          if (!bracket) bracket = token;\n          brackets.push('}');\n        } else if (brackets.length === 0) {\n          if (type === ';') {\n            if (colon) {\n              this.decl(tokens, customProperty);\n              return;\n            } else {\n              break;\n            }\n          } else if (type === '{') {\n            this.rule(tokens);\n            return;\n          } else if (type === '}') {\n            this.tokenizer.back(tokens.pop());\n            end = true;\n            break;\n          } else if (type === ':') {\n            colon = true;\n          }\n        } else if (type === brackets[brackets.length - 1]) {\n          brackets.pop();\n          if (brackets.length === 0) bracket = null;\n        }\n        token = this.tokenizer.nextToken();\n      }\n      if (this.tokenizer.endOfFile()) end = true;\n      if (brackets.length > 0) this.unclosedBracket(bracket);\n      if (end && colon) {\n        if (!customProperty) {\n          while (tokens.length) {\n            token = tokens[tokens.length - 1][0];\n            if (token !== 'space' && token !== 'comment') break;\n            this.tokenizer.back(tokens.pop());\n          }\n        }\n        this.decl(tokens, customProperty);\n      } else {\n        this.unknownWord(tokens);\n      }\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var token;\n      while (!this.tokenizer.endOfFile()) {\n        token = this.tokenizer.nextToken();\n        switch (token[0]) {\n          case 'space':\n            this.spaces += token[1];\n            break;\n          case ';':\n            this.freeSemicolon(token);\n            break;\n          case '}':\n            this.end(token);\n            break;\n          case 'comment':\n            this.comment(token);\n            break;\n          case 'at-word':\n            this.atrule(token);\n            break;\n          case '{':\n            this.emptyRule(token);\n            break;\n          default:\n            this.other(token);\n            break;\n        }\n      }\n      this.endFile();\n    }\n  }, {\n    key: \"precheckMissedSemicolon\",\n    value: function precheckMissedSemicolon() {}\n  }, {\n    key: \"raw\",\n    value: function raw(node, prop, tokens, customProperty) {\n      var token, type;\n      var length = tokens.length;\n      var value = '';\n      var clean = true;\n      var next, prev;\n      for (var i = 0; i < length; i += 1) {\n        token = tokens[i];\n        type = token[0];\n        if (type === 'space' && i === length - 1 && !customProperty) {\n          clean = false;\n        } else if (type === 'comment') {\n          prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';\n          next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';\n          if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n            if (value.slice(-1) === ',') {\n              clean = false;\n            } else {\n              value += token[1];\n            }\n          } else {\n            clean = false;\n          }\n        } else {\n          value += token[1];\n        }\n      }\n      if (!clean) {\n        var raw = tokens.reduce(function (all, i) {\n          return all + i[1];\n        }, '');\n        node.raws[prop] = {\n          raw: raw,\n          value: value\n        };\n      }\n      node[prop] = value;\n    }\n  }, {\n    key: \"rule\",\n    value: function rule(tokens) {\n      tokens.pop();\n      var node = new Rule();\n      this.init(node, tokens[0][2]);\n      node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n      this.raw(node, 'selector', tokens);\n      this.current = node;\n    }\n  }, {\n    key: \"spacesAndCommentsFromEnd\",\n    value: function spacesAndCommentsFromEnd(tokens) {\n      var lastTokenType;\n      var spaces = '';\n      while (tokens.length) {\n        lastTokenType = tokens[tokens.length - 1][0];\n        if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n        spaces = tokens.pop()[1] + spaces;\n      }\n      return spaces;\n    }\n  }, {\n    key: \"spacesAndCommentsFromStart\",\n    value: function spacesAndCommentsFromStart(tokens) {\n      var next;\n      var spaces = '';\n      while (tokens.length) {\n        next = tokens[0][0];\n        if (next !== 'space' && next !== 'comment') break;\n        spaces += tokens.shift()[1];\n      }\n      return spaces;\n    }\n  }, {\n    key: \"spacesFromEnd\",\n    value: function spacesFromEnd(tokens) {\n      var lastTokenType;\n      var spaces = '';\n      while (tokens.length) {\n        lastTokenType = tokens[tokens.length - 1][0];\n        if (lastTokenType !== 'space') break;\n        spaces = tokens.pop()[1] + spaces;\n      }\n      return spaces;\n    }\n  }, {\n    key: \"stringFrom\",\n    value: function stringFrom(tokens, from) {\n      var result = '';\n      for (var i = from; i < tokens.length; i++) {\n        result += tokens[i][1];\n      }\n      tokens.splice(from, tokens.length - from);\n      return result;\n    }\n  }, {\n    key: \"unclosedBlock\",\n    value: function unclosedBlock() {\n      var pos = this.current.source.start;\n      throw this.input.error('Unclosed block', pos.line, pos.column);\n    }\n  }, {\n    key: \"unclosedBracket\",\n    value: function unclosedBracket(bracket) {\n      throw this.input.error('Unclosed bracket', {\n        offset: bracket[2]\n      }, {\n        offset: bracket[2] + 1\n      });\n    }\n  }, {\n    key: \"unexpectedClose\",\n    value: function unexpectedClose(token) {\n      throw this.input.error('Unexpected }', {\n        offset: token[2]\n      }, {\n        offset: token[2] + 1\n      });\n    }\n  }, {\n    key: \"unknownWord\",\n    value: function unknownWord(tokens) {\n      throw this.input.error('Unknown word', {\n        offset: tokens[0][2]\n      }, {\n        offset: tokens[0][2] + tokens[0][1].length\n      });\n    }\n  }, {\n    key: \"unnamedAtrule\",\n    value: function unnamedAtrule(node, token) {\n      throw this.input.error('At-rule without name', {\n        offset: token[2]\n      }, {\n        offset: token[2] + token[1].length\n      });\n    }\n  }]);\n  return Parser;\n}();\nmodule.exports = Parser;","map":{"version":3,"names":["_slicedToArray","require","_classCallCheck","_createClass","Declaration","tokenizer","Comment","AtRule","Root","Rule","SAFE_COMMENT_NEIGHBOR","empty","space","findLastWithPosition","tokens","i","length","token","pos","Parser","input","root","current","spaces","semicolon","customProperty","createTokenizer","source","start","column","line","offset","key","value","atrule","node","name","slice","unnamedAtrule","init","type","prev","shift","last","open","params","brackets","endOfFile","nextToken","push","pop","end","getPosition","raws","between","spacesAndCommentsFromEnd","afterName","spacesAndCommentsFromStart","raw","nodes","checkMissedSemicolon","colon","founded","j","error","_ref","entries","_ref2","element","doubleColon","comment","text","test","left","right","match","decl","unknownWord","before","prop","firstSpaces","next","precheckMissedSemicolon","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","trim","indexOf","hasWord","some","map","join","concat","includes","emptyRule","selector","after","parent","unexpectedClose","endFile","unclosedBlock","position","freeSemicolon","ownSemicolon","fromOffset","col","other","bracket","startsWith","rule","back","unclosedBracket","parse","clean","reduce","all","lastTokenType","from","result","splice","module","exports"],"sources":["C:/JsonMobile/frontend/node_modules/styled-components/node_modules/postcss/lib/parser.js"],"sourcesContent":["'use strict'\r\n\r\nlet Declaration = require('./declaration')\r\nlet tokenizer = require('./tokenize')\r\nlet Comment = require('./comment')\r\nlet AtRule = require('./at-rule')\r\nlet Root = require('./root')\r\nlet Rule = require('./rule')\r\n\r\nconst SAFE_COMMENT_NEIGHBOR = {\r\n  empty: true,\r\n  space: true\r\n}\r\n\r\nfunction findLastWithPosition(tokens) {\r\n  for (let i = tokens.length - 1; i >= 0; i--) {\r\n    let token = tokens[i]\r\n    let pos = token[3] || token[2]\r\n    if (pos) return pos\r\n  }\r\n}\r\n\r\nclass Parser {\r\n  constructor(input) {\r\n    this.input = input\r\n\r\n    this.root = new Root()\r\n    this.current = this.root\r\n    this.spaces = ''\r\n    this.semicolon = false\r\n    this.customProperty = false\r\n\r\n    this.createTokenizer()\r\n    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }\r\n  }\r\n\r\n  atrule(token) {\r\n    let node = new AtRule()\r\n    node.name = token[1].slice(1)\r\n    if (node.name === '') {\r\n      this.unnamedAtrule(node, token)\r\n    }\r\n    this.init(node, token[2])\r\n\r\n    let type\r\n    let prev\r\n    let shift\r\n    let last = false\r\n    let open = false\r\n    let params = []\r\n    let brackets = []\r\n\r\n    while (!this.tokenizer.endOfFile()) {\r\n      token = this.tokenizer.nextToken()\r\n      type = token[0]\r\n\r\n      if (type === '(' || type === '[') {\r\n        brackets.push(type === '(' ? ')' : ']')\r\n      } else if (type === '{' && brackets.length > 0) {\r\n        brackets.push('}')\r\n      } else if (type === brackets[brackets.length - 1]) {\r\n        brackets.pop()\r\n      }\r\n\r\n      if (brackets.length === 0) {\r\n        if (type === ';') {\r\n          node.source.end = this.getPosition(token[2])\r\n          node.source.end.offset++\r\n          this.semicolon = true\r\n          break\r\n        } else if (type === '{') {\r\n          open = true\r\n          break\r\n        } else if (type === '}') {\r\n          if (params.length > 0) {\r\n            shift = params.length - 1\r\n            prev = params[shift]\r\n            while (prev && prev[0] === 'space') {\r\n              prev = params[--shift]\r\n            }\r\n            if (prev) {\r\n              node.source.end = this.getPosition(prev[3] || prev[2])\r\n              node.source.end.offset++\r\n            }\r\n          }\r\n          this.end(token)\r\n          break\r\n        } else {\r\n          params.push(token)\r\n        }\r\n      } else {\r\n        params.push(token)\r\n      }\r\n\r\n      if (this.tokenizer.endOfFile()) {\r\n        last = true\r\n        break\r\n      }\r\n    }\r\n\r\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\r\n    if (params.length) {\r\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\r\n      this.raw(node, 'params', params)\r\n      if (last) {\r\n        token = params[params.length - 1]\r\n        node.source.end = this.getPosition(token[3] || token[2])\r\n        node.source.end.offset++\r\n        this.spaces = node.raws.between\r\n        node.raws.between = ''\r\n      }\r\n    } else {\r\n      node.raws.afterName = ''\r\n      node.params = ''\r\n    }\r\n\r\n    if (open) {\r\n      node.nodes = []\r\n      this.current = node\r\n    }\r\n  }\r\n\r\n  checkMissedSemicolon(tokens) {\r\n    let colon = this.colon(tokens)\r\n    if (colon === false) return\r\n\r\n    let founded = 0\r\n    let token\r\n    for (let j = colon - 1; j >= 0; j--) {\r\n      token = tokens[j]\r\n      if (token[0] !== 'space') {\r\n        founded += 1\r\n        if (founded === 2) break\r\n      }\r\n    }\r\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\r\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\r\n    // And because we need it after that one we do +1 to get the next one.\r\n    throw this.input.error(\r\n      'Missed semicolon',\r\n      token[0] === 'word' ? token[3] + 1 : token[2]\r\n    )\r\n  }\r\n\r\n  colon(tokens) {\r\n    let brackets = 0\r\n    let token, type, prev\r\n    for (let [i, element] of tokens.entries()) {\r\n      token = element\r\n      type = token[0]\r\n\r\n      if (type === '(') {\r\n        brackets += 1\r\n      }\r\n      if (type === ')') {\r\n        brackets -= 1\r\n      }\r\n      if (brackets === 0 && type === ':') {\r\n        if (!prev) {\r\n          this.doubleColon(token)\r\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\r\n          continue\r\n        } else {\r\n          return i\r\n        }\r\n      }\r\n\r\n      prev = token\r\n    }\r\n    return false\r\n  }\r\n\r\n  comment(token) {\r\n    let node = new Comment()\r\n    this.init(node, token[2])\r\n    node.source.end = this.getPosition(token[3] || token[2])\r\n    node.source.end.offset++\r\n\r\n    let text = token[1].slice(2, -2)\r\n    if (/^\\s*$/.test(text)) {\r\n      node.text = ''\r\n      node.raws.left = text\r\n      node.raws.right = ''\r\n    } else {\r\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\r\n      node.text = match[2]\r\n      node.raws.left = match[1]\r\n      node.raws.right = match[3]\r\n    }\r\n  }\r\n\r\n  createTokenizer() {\r\n    this.tokenizer = tokenizer(this.input)\r\n  }\r\n\r\n  decl(tokens, customProperty) {\r\n    let node = new Declaration()\r\n    this.init(node, tokens[0][2])\r\n\r\n    let last = tokens[tokens.length - 1]\r\n    if (last[0] === ';') {\r\n      this.semicolon = true\r\n      tokens.pop()\r\n    }\r\n\r\n    node.source.end = this.getPosition(\r\n      last[3] || last[2] || findLastWithPosition(tokens)\r\n    )\r\n    node.source.end.offset++\r\n\r\n    while (tokens[0][0] !== 'word') {\r\n      if (tokens.length === 1) this.unknownWord(tokens)\r\n      node.raws.before += tokens.shift()[1]\r\n    }\r\n    node.source.start = this.getPosition(tokens[0][2])\r\n\r\n    node.prop = ''\r\n    while (tokens.length) {\r\n      let type = tokens[0][0]\r\n      if (type === ':' || type === 'space' || type === 'comment') {\r\n        break\r\n      }\r\n      node.prop += tokens.shift()[1]\r\n    }\r\n\r\n    node.raws.between = ''\r\n\r\n    let token\r\n    while (tokens.length) {\r\n      token = tokens.shift()\r\n\r\n      if (token[0] === ':') {\r\n        node.raws.between += token[1]\r\n        break\r\n      } else {\r\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\r\n          this.unknownWord([token])\r\n        }\r\n        node.raws.between += token[1]\r\n      }\r\n    }\r\n\r\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\r\n      node.raws.before += node.prop[0]\r\n      node.prop = node.prop.slice(1)\r\n    }\r\n\r\n    let firstSpaces = []\r\n    let next\r\n    while (tokens.length) {\r\n      next = tokens[0][0]\r\n      if (next !== 'space' && next !== 'comment') break\r\n      firstSpaces.push(tokens.shift())\r\n    }\r\n\r\n    this.precheckMissedSemicolon(tokens)\r\n\r\n    for (let i = tokens.length - 1; i >= 0; i--) {\r\n      token = tokens[i]\r\n      if (token[1].toLowerCase() === '!important') {\r\n        node.important = true\r\n        let string = this.stringFrom(tokens, i)\r\n        string = this.spacesFromEnd(tokens) + string\r\n        if (string !== ' !important') node.raws.important = string\r\n        break\r\n      } else if (token[1].toLowerCase() === 'important') {\r\n        let cache = tokens.slice(0)\r\n        let str = ''\r\n        for (let j = i; j > 0; j--) {\r\n          let type = cache[j][0]\r\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\r\n            break\r\n          }\r\n          str = cache.pop()[1] + str\r\n        }\r\n        if (str.trim().indexOf('!') === 0) {\r\n          node.important = true\r\n          node.raws.important = str\r\n          tokens = cache\r\n        }\r\n      }\r\n\r\n      if (token[0] !== 'space' && token[0] !== 'comment') {\r\n        break\r\n      }\r\n    }\r\n\r\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\r\n\r\n    if (hasWord) {\r\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\r\n      firstSpaces = []\r\n    }\r\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\r\n\r\n    if (node.value.includes(':') && !customProperty) {\r\n      this.checkMissedSemicolon(tokens)\r\n    }\r\n  }\r\n\r\n  doubleColon(token) {\r\n    throw this.input.error(\r\n      'Double colon',\r\n      { offset: token[2] },\r\n      { offset: token[2] + token[1].length }\r\n    )\r\n  }\r\n\r\n  emptyRule(token) {\r\n    let node = new Rule()\r\n    this.init(node, token[2])\r\n    node.selector = ''\r\n    node.raws.between = ''\r\n    this.current = node\r\n  }\r\n\r\n  end(token) {\r\n    if (this.current.nodes && this.current.nodes.length) {\r\n      this.current.raws.semicolon = this.semicolon\r\n    }\r\n    this.semicolon = false\r\n\r\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\r\n    this.spaces = ''\r\n\r\n    if (this.current.parent) {\r\n      this.current.source.end = this.getPosition(token[2])\r\n      this.current.source.end.offset++\r\n      this.current = this.current.parent\r\n    } else {\r\n      this.unexpectedClose(token)\r\n    }\r\n  }\r\n\r\n  endFile() {\r\n    if (this.current.parent) this.unclosedBlock()\r\n    if (this.current.nodes && this.current.nodes.length) {\r\n      this.current.raws.semicolon = this.semicolon\r\n    }\r\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\r\n    this.root.source.end = this.getPosition(this.tokenizer.position())\r\n  }\r\n\r\n  freeSemicolon(token) {\r\n    this.spaces += token[1]\r\n    if (this.current.nodes) {\r\n      let prev = this.current.nodes[this.current.nodes.length - 1]\r\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\r\n        prev.raws.ownSemicolon = this.spaces\r\n        this.spaces = ''\r\n      }\r\n    }\r\n  }\r\n\r\n  // Helpers\r\n\r\n  getPosition(offset) {\r\n    let pos = this.input.fromOffset(offset)\r\n    return {\r\n      column: pos.col,\r\n      line: pos.line,\r\n      offset\r\n    }\r\n  }\r\n\r\n  init(node, offset) {\r\n    this.current.push(node)\r\n    node.source = {\r\n      input: this.input,\r\n      start: this.getPosition(offset)\r\n    }\r\n    node.raws.before = this.spaces\r\n    this.spaces = ''\r\n    if (node.type !== 'comment') this.semicolon = false\r\n  }\r\n\r\n  other(start) {\r\n    let end = false\r\n    let type = null\r\n    let colon = false\r\n    let bracket = null\r\n    let brackets = []\r\n    let customProperty = start[1].startsWith('--')\r\n\r\n    let tokens = []\r\n    let token = start\r\n    while (token) {\r\n      type = token[0]\r\n      tokens.push(token)\r\n\r\n      if (type === '(' || type === '[') {\r\n        if (!bracket) bracket = token\r\n        brackets.push(type === '(' ? ')' : ']')\r\n      } else if (customProperty && colon && type === '{') {\r\n        if (!bracket) bracket = token\r\n        brackets.push('}')\r\n      } else if (brackets.length === 0) {\r\n        if (type === ';') {\r\n          if (colon) {\r\n            this.decl(tokens, customProperty)\r\n            return\r\n          } else {\r\n            break\r\n          }\r\n        } else if (type === '{') {\r\n          this.rule(tokens)\r\n          return\r\n        } else if (type === '}') {\r\n          this.tokenizer.back(tokens.pop())\r\n          end = true\r\n          break\r\n        } else if (type === ':') {\r\n          colon = true\r\n        }\r\n      } else if (type === brackets[brackets.length - 1]) {\r\n        brackets.pop()\r\n        if (brackets.length === 0) bracket = null\r\n      }\r\n\r\n      token = this.tokenizer.nextToken()\r\n    }\r\n\r\n    if (this.tokenizer.endOfFile()) end = true\r\n    if (brackets.length > 0) this.unclosedBracket(bracket)\r\n\r\n    if (end && colon) {\r\n      if (!customProperty) {\r\n        while (tokens.length) {\r\n          token = tokens[tokens.length - 1][0]\r\n          if (token !== 'space' && token !== 'comment') break\r\n          this.tokenizer.back(tokens.pop())\r\n        }\r\n      }\r\n      this.decl(tokens, customProperty)\r\n    } else {\r\n      this.unknownWord(tokens)\r\n    }\r\n  }\r\n\r\n  parse() {\r\n    let token\r\n    while (!this.tokenizer.endOfFile()) {\r\n      token = this.tokenizer.nextToken()\r\n\r\n      switch (token[0]) {\r\n        case 'space':\r\n          this.spaces += token[1]\r\n          break\r\n\r\n        case ';':\r\n          this.freeSemicolon(token)\r\n          break\r\n\r\n        case '}':\r\n          this.end(token)\r\n          break\r\n\r\n        case 'comment':\r\n          this.comment(token)\r\n          break\r\n\r\n        case 'at-word':\r\n          this.atrule(token)\r\n          break\r\n\r\n        case '{':\r\n          this.emptyRule(token)\r\n          break\r\n\r\n        default:\r\n          this.other(token)\r\n          break\r\n      }\r\n    }\r\n    this.endFile()\r\n  }\r\n\r\n  precheckMissedSemicolon(/* tokens */) {\r\n    // Hook for Safe Parser\r\n  }\r\n\r\n  raw(node, prop, tokens, customProperty) {\r\n    let token, type\r\n    let length = tokens.length\r\n    let value = ''\r\n    let clean = true\r\n    let next, prev\r\n\r\n    for (let i = 0; i < length; i += 1) {\r\n      token = tokens[i]\r\n      type = token[0]\r\n      if (type === 'space' && i === length - 1 && !customProperty) {\r\n        clean = false\r\n      } else if (type === 'comment') {\r\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\r\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\r\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\r\n          if (value.slice(-1) === ',') {\r\n            clean = false\r\n          } else {\r\n            value += token[1]\r\n          }\r\n        } else {\r\n          clean = false\r\n        }\r\n      } else {\r\n        value += token[1]\r\n      }\r\n    }\r\n    if (!clean) {\r\n      let raw = tokens.reduce((all, i) => all + i[1], '')\r\n      node.raws[prop] = { raw, value }\r\n    }\r\n    node[prop] = value\r\n  }\r\n\r\n  rule(tokens) {\r\n    tokens.pop()\r\n\r\n    let node = new Rule()\r\n    this.init(node, tokens[0][2])\r\n\r\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\r\n    this.raw(node, 'selector', tokens)\r\n    this.current = node\r\n  }\r\n\r\n  spacesAndCommentsFromEnd(tokens) {\r\n    let lastTokenType\r\n    let spaces = ''\r\n    while (tokens.length) {\r\n      lastTokenType = tokens[tokens.length - 1][0]\r\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\r\n      spaces = tokens.pop()[1] + spaces\r\n    }\r\n    return spaces\r\n  }\r\n\r\n  // Errors\r\n\r\n  spacesAndCommentsFromStart(tokens) {\r\n    let next\r\n    let spaces = ''\r\n    while (tokens.length) {\r\n      next = tokens[0][0]\r\n      if (next !== 'space' && next !== 'comment') break\r\n      spaces += tokens.shift()[1]\r\n    }\r\n    return spaces\r\n  }\r\n\r\n  spacesFromEnd(tokens) {\r\n    let lastTokenType\r\n    let spaces = ''\r\n    while (tokens.length) {\r\n      lastTokenType = tokens[tokens.length - 1][0]\r\n      if (lastTokenType !== 'space') break\r\n      spaces = tokens.pop()[1] + spaces\r\n    }\r\n    return spaces\r\n  }\r\n\r\n  stringFrom(tokens, from) {\r\n    let result = ''\r\n    for (let i = from; i < tokens.length; i++) {\r\n      result += tokens[i][1]\r\n    }\r\n    tokens.splice(from, tokens.length - from)\r\n    return result\r\n  }\r\n\r\n  unclosedBlock() {\r\n    let pos = this.current.source.start\r\n    throw this.input.error('Unclosed block', pos.line, pos.column)\r\n  }\r\n\r\n  unclosedBracket(bracket) {\r\n    throw this.input.error(\r\n      'Unclosed bracket',\r\n      { offset: bracket[2] },\r\n      { offset: bracket[2] + 1 }\r\n    )\r\n  }\r\n\r\n  unexpectedClose(token) {\r\n    throw this.input.error(\r\n      'Unexpected }',\r\n      { offset: token[2] },\r\n      { offset: token[2] + 1 }\r\n    )\r\n  }\r\n\r\n  unknownWord(tokens) {\r\n    throw this.input.error(\r\n      'Unknown word',\r\n      { offset: tokens[0][2] },\r\n      { offset: tokens[0][2] + tokens[0][1].length }\r\n    )\r\n  }\r\n\r\n  unnamedAtrule(node, token) {\r\n    throw this.input.error(\r\n      'At-rule without name',\r\n      { offset: token[2] },\r\n      { offset: token[2] + token[1].length }\r\n    )\r\n  }\r\n}\r\n\r\nmodule.exports = Parser\r\n"],"mappings":"AAAA,YAAY;;AAAA,IAAAA,cAAA,GAAAC,OAAA;AAAA,IAAAC,eAAA,GAAAD,OAAA;AAAA,IAAAE,YAAA,GAAAF,OAAA;AAEZ,IAAIG,WAAW,GAAGH,OAAO,CAAC,eAAe,CAAC;AAC1C,IAAII,SAAS,GAAGJ,OAAO,CAAC,YAAY,CAAC;AACrC,IAAIK,OAAO,GAAGL,OAAO,CAAC,WAAW,CAAC;AAClC,IAAIM,MAAM,GAAGN,OAAO,CAAC,WAAW,CAAC;AACjC,IAAIO,IAAI,GAAGP,OAAO,CAAC,QAAQ,CAAC;AAC5B,IAAIQ,IAAI,GAAGR,OAAO,CAAC,QAAQ,CAAC;AAE5B,IAAMS,qBAAqB,GAAG;EAC5BC,KAAK,EAAE,IAAI;EACXC,KAAK,EAAE;AACT,CAAC;AAED,SAASC,oBAAoBA,CAACC,MAAM,EAAE;EACpC,KAAK,IAAIC,CAAC,GAAGD,MAAM,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC3C,IAAIE,KAAK,GAAGH,MAAM,CAACC,CAAC,CAAC;IACrB,IAAIG,GAAG,GAAGD,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC;IAC9B,IAAIC,GAAG,EAAE,OAAOA,GAAG;EACrB;AACF;AAAC,IAEKC,MAAM;EACV,SAAAA,OAAYC,KAAK,EAAE;IAAAlB,eAAA,OAAAiB,MAAA;IACjB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAElB,IAAI,CAACC,IAAI,GAAG,IAAIb,IAAI,CAAC,CAAC;IACtB,IAAI,CAACc,OAAO,GAAG,IAAI,CAACD,IAAI;IACxB,IAAI,CAACE,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,cAAc,GAAG,KAAK;IAE3B,IAAI,CAACC,eAAe,CAAC,CAAC;IACtB,IAAI,CAACL,IAAI,CAACM,MAAM,GAAG;MAAEP,KAAK,EAALA,KAAK;MAAEQ,KAAK,EAAE;QAAEC,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAE,CAAC;QAAEC,MAAM,EAAE;MAAE;IAAE,CAAC;EACxE;EAAC5B,YAAA,CAAAgB,MAAA;IAAAa,GAAA;IAAAC,KAAA,EAED,SAAAC,OAAOjB,KAAK,EAAE;MACZ,IAAIkB,IAAI,GAAG,IAAI5B,MAAM,CAAC,CAAC;MACvB4B,IAAI,CAACC,IAAI,GAAGnB,KAAK,CAAC,CAAC,CAAC,CAACoB,KAAK,CAAC,CAAC,CAAC;MAC7B,IAAIF,IAAI,CAACC,IAAI,KAAK,EAAE,EAAE;QACpB,IAAI,CAACE,aAAa,CAACH,IAAI,EAAElB,KAAK,CAAC;MACjC;MACA,IAAI,CAACsB,IAAI,CAACJ,IAAI,EAAElB,KAAK,CAAC,CAAC,CAAC,CAAC;MAEzB,IAAIuB,IAAI;MACR,IAAIC,IAAI;MACR,IAAIC,KAAK;MACT,IAAIC,IAAI,GAAG,KAAK;MAChB,IAAIC,IAAI,GAAG,KAAK;MAChB,IAAIC,MAAM,GAAG,EAAE;MACf,IAAIC,QAAQ,GAAG,EAAE;MAEjB,OAAO,CAAC,IAAI,CAACzC,SAAS,CAAC0C,SAAS,CAAC,CAAC,EAAE;QAClC9B,KAAK,GAAG,IAAI,CAACZ,SAAS,CAAC2C,SAAS,CAAC,CAAC;QAClCR,IAAI,GAAGvB,KAAK,CAAC,CAAC,CAAC;QAEf,IAAIuB,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;UAChCM,QAAQ,CAACG,IAAI,CAACT,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;QACzC,CAAC,MAAM,IAAIA,IAAI,KAAK,GAAG,IAAIM,QAAQ,CAAC9B,MAAM,GAAG,CAAC,EAAE;UAC9C8B,QAAQ,CAACG,IAAI,CAAC,GAAG,CAAC;QACpB,CAAC,MAAM,IAAIT,IAAI,KAAKM,QAAQ,CAACA,QAAQ,CAAC9B,MAAM,GAAG,CAAC,CAAC,EAAE;UACjD8B,QAAQ,CAACI,GAAG,CAAC,CAAC;QAChB;QAEA,IAAIJ,QAAQ,CAAC9B,MAAM,KAAK,CAAC,EAAE;UACzB,IAAIwB,IAAI,KAAK,GAAG,EAAE;YAChBL,IAAI,CAACR,MAAM,CAACwB,GAAG,GAAG,IAAI,CAACC,WAAW,CAACnC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5CkB,IAAI,CAACR,MAAM,CAACwB,GAAG,CAACpB,MAAM,EAAE;YACxB,IAAI,CAACP,SAAS,GAAG,IAAI;YACrB;UACF,CAAC,MAAM,IAAIgB,IAAI,KAAK,GAAG,EAAE;YACvBI,IAAI,GAAG,IAAI;YACX;UACF,CAAC,MAAM,IAAIJ,IAAI,KAAK,GAAG,EAAE;YACvB,IAAIK,MAAM,CAAC7B,MAAM,GAAG,CAAC,EAAE;cACrB0B,KAAK,GAAGG,MAAM,CAAC7B,MAAM,GAAG,CAAC;cACzByB,IAAI,GAAGI,MAAM,CAACH,KAAK,CAAC;cACpB,OAAOD,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;gBAClCA,IAAI,GAAGI,MAAM,CAAC,EAAEH,KAAK,CAAC;cACxB;cACA,IAAID,IAAI,EAAE;gBACRN,IAAI,CAACR,MAAM,CAACwB,GAAG,GAAG,IAAI,CAACC,WAAW,CAACX,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAC;gBACtDN,IAAI,CAACR,MAAM,CAACwB,GAAG,CAACpB,MAAM,EAAE;cAC1B;YACF;YACA,IAAI,CAACoB,GAAG,CAAClC,KAAK,CAAC;YACf;UACF,CAAC,MAAM;YACL4B,MAAM,CAACI,IAAI,CAAChC,KAAK,CAAC;UACpB;QACF,CAAC,MAAM;UACL4B,MAAM,CAACI,IAAI,CAAChC,KAAK,CAAC;QACpB;QAEA,IAAI,IAAI,CAACZ,SAAS,CAAC0C,SAAS,CAAC,CAAC,EAAE;UAC9BJ,IAAI,GAAG,IAAI;UACX;QACF;MACF;MAEAR,IAAI,CAACkB,IAAI,CAACC,OAAO,GAAG,IAAI,CAACC,wBAAwB,CAACV,MAAM,CAAC;MACzD,IAAIA,MAAM,CAAC7B,MAAM,EAAE;QACjBmB,IAAI,CAACkB,IAAI,CAACG,SAAS,GAAG,IAAI,CAACC,0BAA0B,CAACZ,MAAM,CAAC;QAC7D,IAAI,CAACa,GAAG,CAACvB,IAAI,EAAE,QAAQ,EAAEU,MAAM,CAAC;QAChC,IAAIF,IAAI,EAAE;UACR1B,KAAK,GAAG4B,MAAM,CAACA,MAAM,CAAC7B,MAAM,GAAG,CAAC,CAAC;UACjCmB,IAAI,CAACR,MAAM,CAACwB,GAAG,GAAG,IAAI,CAACC,WAAW,CAACnC,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,CAAC;UACxDkB,IAAI,CAACR,MAAM,CAACwB,GAAG,CAACpB,MAAM,EAAE;UACxB,IAAI,CAACR,MAAM,GAAGY,IAAI,CAACkB,IAAI,CAACC,OAAO;UAC/BnB,IAAI,CAACkB,IAAI,CAACC,OAAO,GAAG,EAAE;QACxB;MACF,CAAC,MAAM;QACLnB,IAAI,CAACkB,IAAI,CAACG,SAAS,GAAG,EAAE;QACxBrB,IAAI,CAACU,MAAM,GAAG,EAAE;MAClB;MAEA,IAAID,IAAI,EAAE;QACRT,IAAI,CAACwB,KAAK,GAAG,EAAE;QACf,IAAI,CAACrC,OAAO,GAAGa,IAAI;MACrB;IACF;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAA2B,qBAAqB9C,MAAM,EAAE;MAC3B,IAAI+C,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC/C,MAAM,CAAC;MAC9B,IAAI+C,KAAK,KAAK,KAAK,EAAE;MAErB,IAAIC,OAAO,GAAG,CAAC;MACf,IAAI7C,KAAK;MACT,KAAK,IAAI8C,CAAC,GAAGF,KAAK,GAAG,CAAC,EAAEE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACnC9C,KAAK,GAAGH,MAAM,CAACiD,CAAC,CAAC;QACjB,IAAI9C,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UACxB6C,OAAO,IAAI,CAAC;UACZ,IAAIA,OAAO,KAAK,CAAC,EAAE;QACrB;MACF;MAIA,MAAM,IAAI,CAAC1C,KAAK,CAAC4C,KAAK,CACpB,kBAAkB,EAClB/C,KAAK,CAAC,CAAC,CAAC,KAAK,MAAM,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGA,KAAK,CAAC,CAAC,CAC9C,CAAC;IACH;EAAC;IAAAe,GAAA;IAAAC,KAAA,EAED,SAAA4B,MAAM/C,MAAM,EAAE;MACZ,IAAIgC,QAAQ,GAAG,CAAC;MAChB,IAAI7B,KAAK,EAAEuB,IAAI,EAAEC,IAAI;MACrB,SAAAwB,IAAA,IAAyBnD,MAAM,CAACoD,OAAO,CAAC,CAAC,EAAE;QAAA,IAAAC,KAAA,GAAAnE,cAAA,CAAAiE,IAAA;QAAA,IAAjClD,CAAC,GAAAoD,KAAA;QAAA,IAAEC,OAAO,GAAAD,KAAA;QAClBlD,KAAK,GAAGmD,OAAO;QACf5B,IAAI,GAAGvB,KAAK,CAAC,CAAC,CAAC;QAEf,IAAIuB,IAAI,KAAK,GAAG,EAAE;UAChBM,QAAQ,IAAI,CAAC;QACf;QACA,IAAIN,IAAI,KAAK,GAAG,EAAE;UAChBM,QAAQ,IAAI,CAAC;QACf;QACA,IAAIA,QAAQ,KAAK,CAAC,IAAIN,IAAI,KAAK,GAAG,EAAE;UAClC,IAAI,CAACC,IAAI,EAAE;YACT,IAAI,CAAC4B,WAAW,CAACpD,KAAK,CAAC;UACzB,CAAC,MAAM,IAAIwB,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;YACrD;UACF,CAAC,MAAM;YACL,OAAO1B,CAAC;UACV;QACF;QAEA0B,IAAI,GAAGxB,KAAK;MACd;MACA,OAAO,KAAK;IACd;EAAC;IAAAe,GAAA;IAAAC,KAAA,EAED,SAAAqC,QAAQrD,KAAK,EAAE;MACb,IAAIkB,IAAI,GAAG,IAAI7B,OAAO,CAAC,CAAC;MACxB,IAAI,CAACiC,IAAI,CAACJ,IAAI,EAAElB,KAAK,CAAC,CAAC,CAAC,CAAC;MACzBkB,IAAI,CAACR,MAAM,CAACwB,GAAG,GAAG,IAAI,CAACC,WAAW,CAACnC,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,CAAC;MACxDkB,IAAI,CAACR,MAAM,CAACwB,GAAG,CAACpB,MAAM,EAAE;MAExB,IAAIwC,IAAI,GAAGtD,KAAK,CAAC,CAAC,CAAC,CAACoB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAChC,IAAI,OAAO,CAACmC,IAAI,CAACD,IAAI,CAAC,EAAE;QACtBpC,IAAI,CAACoC,IAAI,GAAG,EAAE;QACdpC,IAAI,CAACkB,IAAI,CAACoB,IAAI,GAAGF,IAAI;QACrBpC,IAAI,CAACkB,IAAI,CAACqB,KAAK,GAAG,EAAE;MACtB,CAAC,MAAM;QACL,IAAIC,KAAK,GAAGJ,IAAI,CAACI,KAAK,CAAC,sBAAsB,CAAC;QAC9CxC,IAAI,CAACoC,IAAI,GAAGI,KAAK,CAAC,CAAC,CAAC;QACpBxC,IAAI,CAACkB,IAAI,CAACoB,IAAI,GAAGE,KAAK,CAAC,CAAC,CAAC;QACzBxC,IAAI,CAACkB,IAAI,CAACqB,KAAK,GAAGC,KAAK,CAAC,CAAC,CAAC;MAC5B;IACF;EAAC;IAAA3C,GAAA;IAAAC,KAAA,EAED,SAAAP,gBAAA,EAAkB;MAChB,IAAI,CAACrB,SAAS,GAAGA,SAAS,CAAC,IAAI,CAACe,KAAK,CAAC;IACxC;EAAC;IAAAY,GAAA;IAAAC,KAAA,EAED,SAAA2C,KAAK9D,MAAM,EAAEW,cAAc,EAAE;MAC3B,IAAIU,IAAI,GAAG,IAAI/B,WAAW,CAAC,CAAC;MAC5B,IAAI,CAACmC,IAAI,CAACJ,IAAI,EAAErB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAE7B,IAAI6B,IAAI,GAAG7B,MAAM,CAACA,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC;MACpC,IAAI2B,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACnB,IAAI,CAACnB,SAAS,GAAG,IAAI;QACrBV,MAAM,CAACoC,GAAG,CAAC,CAAC;MACd;MAEAf,IAAI,CAACR,MAAM,CAACwB,GAAG,GAAG,IAAI,CAACC,WAAW,CAChCT,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,IAAI9B,oBAAoB,CAACC,MAAM,CACnD,CAAC;MACDqB,IAAI,CAACR,MAAM,CAACwB,GAAG,CAACpB,MAAM,EAAE;MAExB,OAAOjB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;QAC9B,IAAIA,MAAM,CAACE,MAAM,KAAK,CAAC,EAAE,IAAI,CAAC6D,WAAW,CAAC/D,MAAM,CAAC;QACjDqB,IAAI,CAACkB,IAAI,CAACyB,MAAM,IAAIhE,MAAM,CAAC4B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MACvC;MACAP,IAAI,CAACR,MAAM,CAACC,KAAK,GAAG,IAAI,CAACwB,WAAW,CAACtC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAElDqB,IAAI,CAAC4C,IAAI,GAAG,EAAE;MACd,OAAOjE,MAAM,CAACE,MAAM,EAAE;QACpB,IAAIwB,IAAI,GAAG1B,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI0B,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,SAAS,EAAE;UAC1D;QACF;QACAL,IAAI,CAAC4C,IAAI,IAAIjE,MAAM,CAAC4B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAChC;MAEAP,IAAI,CAACkB,IAAI,CAACC,OAAO,GAAG,EAAE;MAEtB,IAAIrC,KAAK;MACT,OAAOH,MAAM,CAACE,MAAM,EAAE;QACpBC,KAAK,GAAGH,MAAM,CAAC4B,KAAK,CAAC,CAAC;QAEtB,IAAIzB,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UACpBkB,IAAI,CAACkB,IAAI,CAACC,OAAO,IAAIrC,KAAK,CAAC,CAAC,CAAC;UAC7B;QACF,CAAC,MAAM;UACL,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,MAAM,IAAI,IAAI,CAACuD,IAAI,CAACvD,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;YAC9C,IAAI,CAAC4D,WAAW,CAAC,CAAC5D,KAAK,CAAC,CAAC;UAC3B;UACAkB,IAAI,CAACkB,IAAI,CAACC,OAAO,IAAIrC,KAAK,CAAC,CAAC,CAAC;QAC/B;MACF;MAEA,IAAIkB,IAAI,CAAC4C,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI5C,IAAI,CAAC4C,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAChD5C,IAAI,CAACkB,IAAI,CAACyB,MAAM,IAAI3C,IAAI,CAAC4C,IAAI,CAAC,CAAC,CAAC;QAChC5C,IAAI,CAAC4C,IAAI,GAAG5C,IAAI,CAAC4C,IAAI,CAAC1C,KAAK,CAAC,CAAC,CAAC;MAChC;MAEA,IAAI2C,WAAW,GAAG,EAAE;MACpB,IAAIC,IAAI;MACR,OAAOnE,MAAM,CAACE,MAAM,EAAE;QACpBiE,IAAI,GAAGnE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACnB,IAAImE,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,SAAS,EAAE;QAC5CD,WAAW,CAAC/B,IAAI,CAACnC,MAAM,CAAC4B,KAAK,CAAC,CAAC,CAAC;MAClC;MAEA,IAAI,CAACwC,uBAAuB,CAACpE,MAAM,CAAC;MAEpC,KAAK,IAAIC,CAAC,GAAGD,MAAM,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC3CE,KAAK,GAAGH,MAAM,CAACC,CAAC,CAAC;QACjB,IAAIE,KAAK,CAAC,CAAC,CAAC,CAACkE,WAAW,CAAC,CAAC,KAAK,YAAY,EAAE;UAC3ChD,IAAI,CAACiD,SAAS,GAAG,IAAI;UACrB,IAAIC,MAAM,GAAG,IAAI,CAACC,UAAU,CAACxE,MAAM,EAAEC,CAAC,CAAC;UACvCsE,MAAM,GAAG,IAAI,CAACE,aAAa,CAACzE,MAAM,CAAC,GAAGuE,MAAM;UAC5C,IAAIA,MAAM,KAAK,aAAa,EAAElD,IAAI,CAACkB,IAAI,CAAC+B,SAAS,GAAGC,MAAM;UAC1D;QACF,CAAC,MAAM,IAAIpE,KAAK,CAAC,CAAC,CAAC,CAACkE,WAAW,CAAC,CAAC,KAAK,WAAW,EAAE;UACjD,IAAIK,KAAK,GAAG1E,MAAM,CAACuB,KAAK,CAAC,CAAC,CAAC;UAC3B,IAAIoD,GAAG,GAAG,EAAE;UACZ,KAAK,IAAI1B,CAAC,GAAGhD,CAAC,EAAEgD,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;YAC1B,IAAIvB,KAAI,GAAGgD,KAAK,CAACzB,CAAC,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI0B,GAAG,CAACC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,IAAInD,KAAI,KAAK,OAAO,EAAE;cACrD;YACF;YACAiD,GAAG,GAAGD,KAAK,CAACtC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGuC,GAAG;UAC5B;UACA,IAAIA,GAAG,CAACC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACjCxD,IAAI,CAACiD,SAAS,GAAG,IAAI;YACrBjD,IAAI,CAACkB,IAAI,CAAC+B,SAAS,GAAGK,GAAG;YACzB3E,MAAM,GAAG0E,KAAK;UAChB;QACF;QAEA,IAAIvE,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;UAClD;QACF;MACF;MAEA,IAAI2E,OAAO,GAAG9E,MAAM,CAAC+E,IAAI,CAAC,UAAA9E,CAAC;QAAA,OAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,SAAS;MAAA,EAAC;MAEtE,IAAI6E,OAAO,EAAE;QACXzD,IAAI,CAACkB,IAAI,CAACC,OAAO,IAAI0B,WAAW,CAACc,GAAG,CAAC,UAAA/E,CAAC;UAAA,OAAIA,CAAC,CAAC,CAAC,CAAC;QAAA,EAAC,CAACgF,IAAI,CAAC,EAAE,CAAC;QACxDf,WAAW,GAAG,EAAE;MAClB;MACA,IAAI,CAACtB,GAAG,CAACvB,IAAI,EAAE,OAAO,EAAE6C,WAAW,CAACgB,MAAM,CAAClF,MAAM,CAAC,EAAEW,cAAc,CAAC;MAEnE,IAAIU,IAAI,CAACF,KAAK,CAACgE,QAAQ,CAAC,GAAG,CAAC,IAAI,CAACxE,cAAc,EAAE;QAC/C,IAAI,CAACmC,oBAAoB,CAAC9C,MAAM,CAAC;MACnC;IACF;EAAC;IAAAkB,GAAA;IAAAC,KAAA,EAED,SAAAoC,YAAYpD,KAAK,EAAE;MACjB,MAAM,IAAI,CAACG,KAAK,CAAC4C,KAAK,CACpB,cAAc,EACd;QAAEjC,MAAM,EAAEd,KAAK,CAAC,CAAC;MAAE,CAAC,EACpB;QAAEc,MAAM,EAAEd,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,CAACD;MAAO,CACvC,CAAC;IACH;EAAC;IAAAgB,GAAA;IAAAC,KAAA,EAED,SAAAiE,UAAUjF,KAAK,EAAE;MACf,IAAIkB,IAAI,GAAG,IAAI1B,IAAI,CAAC,CAAC;MACrB,IAAI,CAAC8B,IAAI,CAACJ,IAAI,EAAElB,KAAK,CAAC,CAAC,CAAC,CAAC;MACzBkB,IAAI,CAACgE,QAAQ,GAAG,EAAE;MAClBhE,IAAI,CAACkB,IAAI,CAACC,OAAO,GAAG,EAAE;MACtB,IAAI,CAAChC,OAAO,GAAGa,IAAI;IACrB;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAkB,IAAIlC,KAAK,EAAE;MACT,IAAI,IAAI,CAACK,OAAO,CAACqC,KAAK,IAAI,IAAI,CAACrC,OAAO,CAACqC,KAAK,CAAC3C,MAAM,EAAE;QACnD,IAAI,CAACM,OAAO,CAAC+B,IAAI,CAAC7B,SAAS,GAAG,IAAI,CAACA,SAAS;MAC9C;MACA,IAAI,CAACA,SAAS,GAAG,KAAK;MAEtB,IAAI,CAACF,OAAO,CAAC+B,IAAI,CAAC+C,KAAK,GAAG,CAAC,IAAI,CAAC9E,OAAO,CAAC+B,IAAI,CAAC+C,KAAK,IAAI,EAAE,IAAI,IAAI,CAAC7E,MAAM;MACvE,IAAI,CAACA,MAAM,GAAG,EAAE;MAEhB,IAAI,IAAI,CAACD,OAAO,CAAC+E,MAAM,EAAE;QACvB,IAAI,CAAC/E,OAAO,CAACK,MAAM,CAACwB,GAAG,GAAG,IAAI,CAACC,WAAW,CAACnC,KAAK,CAAC,CAAC,CAAC,CAAC;QACpD,IAAI,CAACK,OAAO,CAACK,MAAM,CAACwB,GAAG,CAACpB,MAAM,EAAE;QAChC,IAAI,CAACT,OAAO,GAAG,IAAI,CAACA,OAAO,CAAC+E,MAAM;MACpC,CAAC,MAAM;QACL,IAAI,CAACC,eAAe,CAACrF,KAAK,CAAC;MAC7B;IACF;EAAC;IAAAe,GAAA;IAAAC,KAAA,EAED,SAAAsE,QAAA,EAAU;MACR,IAAI,IAAI,CAACjF,OAAO,CAAC+E,MAAM,EAAE,IAAI,CAACG,aAAa,CAAC,CAAC;MAC7C,IAAI,IAAI,CAAClF,OAAO,CAACqC,KAAK,IAAI,IAAI,CAACrC,OAAO,CAACqC,KAAK,CAAC3C,MAAM,EAAE;QACnD,IAAI,CAACM,OAAO,CAAC+B,IAAI,CAAC7B,SAAS,GAAG,IAAI,CAACA,SAAS;MAC9C;MACA,IAAI,CAACF,OAAO,CAAC+B,IAAI,CAAC+C,KAAK,GAAG,CAAC,IAAI,CAAC9E,OAAO,CAAC+B,IAAI,CAAC+C,KAAK,IAAI,EAAE,IAAI,IAAI,CAAC7E,MAAM;MACvE,IAAI,CAACF,IAAI,CAACM,MAAM,CAACwB,GAAG,GAAG,IAAI,CAACC,WAAW,CAAC,IAAI,CAAC/C,SAAS,CAACoG,QAAQ,CAAC,CAAC,CAAC;IACpE;EAAC;IAAAzE,GAAA;IAAAC,KAAA,EAED,SAAAyE,cAAczF,KAAK,EAAE;MACnB,IAAI,CAACM,MAAM,IAAIN,KAAK,CAAC,CAAC,CAAC;MACvB,IAAI,IAAI,CAACK,OAAO,CAACqC,KAAK,EAAE;QACtB,IAAIlB,IAAI,GAAG,IAAI,CAACnB,OAAO,CAACqC,KAAK,CAAC,IAAI,CAACrC,OAAO,CAACqC,KAAK,CAAC3C,MAAM,GAAG,CAAC,CAAC;QAC5D,IAAIyB,IAAI,IAAIA,IAAI,CAACD,IAAI,KAAK,MAAM,IAAI,CAACC,IAAI,CAACY,IAAI,CAACsD,YAAY,EAAE;UAC3DlE,IAAI,CAACY,IAAI,CAACsD,YAAY,GAAG,IAAI,CAACpF,MAAM;UACpC,IAAI,CAACA,MAAM,GAAG,EAAE;QAClB;MACF;IACF;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAID,SAAAmB,YAAYrB,MAAM,EAAE;MAClB,IAAIb,GAAG,GAAG,IAAI,CAACE,KAAK,CAACwF,UAAU,CAAC7E,MAAM,CAAC;MACvC,OAAO;QACLF,MAAM,EAAEX,GAAG,CAAC2F,GAAG;QACf/E,IAAI,EAAEZ,GAAG,CAACY,IAAI;QACdC,MAAM,EAANA;MACF,CAAC;IACH;EAAC;IAAAC,GAAA;IAAAC,KAAA,EAED,SAAAM,KAAKJ,IAAI,EAAEJ,MAAM,EAAE;MACjB,IAAI,CAACT,OAAO,CAAC2B,IAAI,CAACd,IAAI,CAAC;MACvBA,IAAI,CAACR,MAAM,GAAG;QACZP,KAAK,EAAE,IAAI,CAACA,KAAK;QACjBQ,KAAK,EAAE,IAAI,CAACwB,WAAW,CAACrB,MAAM;MAChC,CAAC;MACDI,IAAI,CAACkB,IAAI,CAACyB,MAAM,GAAG,IAAI,CAACvD,MAAM;MAC9B,IAAI,CAACA,MAAM,GAAG,EAAE;MAChB,IAAIY,IAAI,CAACK,IAAI,KAAK,SAAS,EAAE,IAAI,CAAChB,SAAS,GAAG,KAAK;IACrD;EAAC;IAAAQ,GAAA;IAAAC,KAAA,EAED,SAAA6E,MAAMlF,KAAK,EAAE;MACX,IAAIuB,GAAG,GAAG,KAAK;MACf,IAAIX,IAAI,GAAG,IAAI;MACf,IAAIqB,KAAK,GAAG,KAAK;MACjB,IAAIkD,OAAO,GAAG,IAAI;MAClB,IAAIjE,QAAQ,GAAG,EAAE;MACjB,IAAIrB,cAAc,GAAGG,KAAK,CAAC,CAAC,CAAC,CAACoF,UAAU,CAAC,IAAI,CAAC;MAE9C,IAAIlG,MAAM,GAAG,EAAE;MACf,IAAIG,KAAK,GAAGW,KAAK;MACjB,OAAOX,KAAK,EAAE;QACZuB,IAAI,GAAGvB,KAAK,CAAC,CAAC,CAAC;QACfH,MAAM,CAACmC,IAAI,CAAChC,KAAK,CAAC;QAElB,IAAIuB,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;UAChC,IAAI,CAACuE,OAAO,EAAEA,OAAO,GAAG9F,KAAK;UAC7B6B,QAAQ,CAACG,IAAI,CAACT,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;QACzC,CAAC,MAAM,IAAIf,cAAc,IAAIoC,KAAK,IAAIrB,IAAI,KAAK,GAAG,EAAE;UAClD,IAAI,CAACuE,OAAO,EAAEA,OAAO,GAAG9F,KAAK;UAC7B6B,QAAQ,CAACG,IAAI,CAAC,GAAG,CAAC;QACpB,CAAC,MAAM,IAAIH,QAAQ,CAAC9B,MAAM,KAAK,CAAC,EAAE;UAChC,IAAIwB,IAAI,KAAK,GAAG,EAAE;YAChB,IAAIqB,KAAK,EAAE;cACT,IAAI,CAACe,IAAI,CAAC9D,MAAM,EAAEW,cAAc,CAAC;cACjC;YACF,CAAC,MAAM;cACL;YACF;UACF,CAAC,MAAM,IAAIe,IAAI,KAAK,GAAG,EAAE;YACvB,IAAI,CAACyE,IAAI,CAACnG,MAAM,CAAC;YACjB;UACF,CAAC,MAAM,IAAI0B,IAAI,KAAK,GAAG,EAAE;YACvB,IAAI,CAACnC,SAAS,CAAC6G,IAAI,CAACpG,MAAM,CAACoC,GAAG,CAAC,CAAC,CAAC;YACjCC,GAAG,GAAG,IAAI;YACV;UACF,CAAC,MAAM,IAAIX,IAAI,KAAK,GAAG,EAAE;YACvBqB,KAAK,GAAG,IAAI;UACd;QACF,CAAC,MAAM,IAAIrB,IAAI,KAAKM,QAAQ,CAACA,QAAQ,CAAC9B,MAAM,GAAG,CAAC,CAAC,EAAE;UACjD8B,QAAQ,CAACI,GAAG,CAAC,CAAC;UACd,IAAIJ,QAAQ,CAAC9B,MAAM,KAAK,CAAC,EAAE+F,OAAO,GAAG,IAAI;QAC3C;QAEA9F,KAAK,GAAG,IAAI,CAACZ,SAAS,CAAC2C,SAAS,CAAC,CAAC;MACpC;MAEA,IAAI,IAAI,CAAC3C,SAAS,CAAC0C,SAAS,CAAC,CAAC,EAAEI,GAAG,GAAG,IAAI;MAC1C,IAAIL,QAAQ,CAAC9B,MAAM,GAAG,CAAC,EAAE,IAAI,CAACmG,eAAe,CAACJ,OAAO,CAAC;MAEtD,IAAI5D,GAAG,IAAIU,KAAK,EAAE;QAChB,IAAI,CAACpC,cAAc,EAAE;UACnB,OAAOX,MAAM,CAACE,MAAM,EAAE;YACpBC,KAAK,GAAGH,MAAM,CAACA,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACpC,IAAIC,KAAK,KAAK,OAAO,IAAIA,KAAK,KAAK,SAAS,EAAE;YAC9C,IAAI,CAACZ,SAAS,CAAC6G,IAAI,CAACpG,MAAM,CAACoC,GAAG,CAAC,CAAC,CAAC;UACnC;QACF;QACA,IAAI,CAAC0B,IAAI,CAAC9D,MAAM,EAAEW,cAAc,CAAC;MACnC,CAAC,MAAM;QACL,IAAI,CAACoD,WAAW,CAAC/D,MAAM,CAAC;MAC1B;IACF;EAAC;IAAAkB,GAAA;IAAAC,KAAA,EAED,SAAAmF,MAAA,EAAQ;MACN,IAAInG,KAAK;MACT,OAAO,CAAC,IAAI,CAACZ,SAAS,CAAC0C,SAAS,CAAC,CAAC,EAAE;QAClC9B,KAAK,GAAG,IAAI,CAACZ,SAAS,CAAC2C,SAAS,CAAC,CAAC;QAElC,QAAQ/B,KAAK,CAAC,CAAC,CAAC;UACd,KAAK,OAAO;YACV,IAAI,CAACM,MAAM,IAAIN,KAAK,CAAC,CAAC,CAAC;YACvB;UAEF,KAAK,GAAG;YACN,IAAI,CAACyF,aAAa,CAACzF,KAAK,CAAC;YACzB;UAEF,KAAK,GAAG;YACN,IAAI,CAACkC,GAAG,CAAClC,KAAK,CAAC;YACf;UAEF,KAAK,SAAS;YACZ,IAAI,CAACqD,OAAO,CAACrD,KAAK,CAAC;YACnB;UAEF,KAAK,SAAS;YACZ,IAAI,CAACiB,MAAM,CAACjB,KAAK,CAAC;YAClB;UAEF,KAAK,GAAG;YACN,IAAI,CAACiF,SAAS,CAACjF,KAAK,CAAC;YACrB;UAEF;YACE,IAAI,CAAC6F,KAAK,CAAC7F,KAAK,CAAC;YACjB;QACJ;MACF;MACA,IAAI,CAACsF,OAAO,CAAC,CAAC;IAChB;EAAC;IAAAvE,GAAA;IAAAC,KAAA,EAED,SAAAiD,wBAAA,EAAsC,CAEtC;EAAC;IAAAlD,GAAA;IAAAC,KAAA,EAED,SAAAyB,IAAIvB,IAAI,EAAE4C,IAAI,EAAEjE,MAAM,EAAEW,cAAc,EAAE;MACtC,IAAIR,KAAK,EAAEuB,IAAI;MACf,IAAIxB,MAAM,GAAGF,MAAM,CAACE,MAAM;MAC1B,IAAIiB,KAAK,GAAG,EAAE;MACd,IAAIoF,KAAK,GAAG,IAAI;MAChB,IAAIpC,IAAI,EAAExC,IAAI;MAEd,KAAK,IAAI1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;QAClCE,KAAK,GAAGH,MAAM,CAACC,CAAC,CAAC;QACjByB,IAAI,GAAGvB,KAAK,CAAC,CAAC,CAAC;QACf,IAAIuB,IAAI,KAAK,OAAO,IAAIzB,CAAC,KAAKC,MAAM,GAAG,CAAC,IAAI,CAACS,cAAc,EAAE;UAC3D4F,KAAK,GAAG,KAAK;QACf,CAAC,MAAM,IAAI7E,IAAI,KAAK,SAAS,EAAE;UAC7BC,IAAI,GAAG3B,MAAM,CAACC,CAAC,GAAG,CAAC,CAAC,GAAGD,MAAM,CAACC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO;UACjDkE,IAAI,GAAGnE,MAAM,CAACC,CAAC,GAAG,CAAC,CAAC,GAAGD,MAAM,CAACC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO;UACjD,IAAI,CAACL,qBAAqB,CAAC+B,IAAI,CAAC,IAAI,CAAC/B,qBAAqB,CAACuE,IAAI,CAAC,EAAE;YAChE,IAAIhD,KAAK,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;cAC3BgF,KAAK,GAAG,KAAK;YACf,CAAC,MAAM;cACLpF,KAAK,IAAIhB,KAAK,CAAC,CAAC,CAAC;YACnB;UACF,CAAC,MAAM;YACLoG,KAAK,GAAG,KAAK;UACf;QACF,CAAC,MAAM;UACLpF,KAAK,IAAIhB,KAAK,CAAC,CAAC,CAAC;QACnB;MACF;MACA,IAAI,CAACoG,KAAK,EAAE;QACV,IAAI3D,GAAG,GAAG5C,MAAM,CAACwG,MAAM,CAAC,UAACC,GAAG,EAAExG,CAAC;UAAA,OAAKwG,GAAG,GAAGxG,CAAC,CAAC,CAAC,CAAC;QAAA,GAAE,EAAE,CAAC;QACnDoB,IAAI,CAACkB,IAAI,CAAC0B,IAAI,CAAC,GAAG;UAAErB,GAAG,EAAHA,GAAG;UAAEzB,KAAK,EAALA;QAAM,CAAC;MAClC;MACAE,IAAI,CAAC4C,IAAI,CAAC,GAAG9C,KAAK;IACpB;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAED,SAAAgF,KAAKnG,MAAM,EAAE;MACXA,MAAM,CAACoC,GAAG,CAAC,CAAC;MAEZ,IAAIf,IAAI,GAAG,IAAI1B,IAAI,CAAC,CAAC;MACrB,IAAI,CAAC8B,IAAI,CAACJ,IAAI,EAAErB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAE7BqB,IAAI,CAACkB,IAAI,CAACC,OAAO,GAAG,IAAI,CAACC,wBAAwB,CAACzC,MAAM,CAAC;MACzD,IAAI,CAAC4C,GAAG,CAACvB,IAAI,EAAE,UAAU,EAAErB,MAAM,CAAC;MAClC,IAAI,CAACQ,OAAO,GAAGa,IAAI;IACrB;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAsB,yBAAyBzC,MAAM,EAAE;MAC/B,IAAI0G,aAAa;MACjB,IAAIjG,MAAM,GAAG,EAAE;MACf,OAAOT,MAAM,CAACE,MAAM,EAAE;QACpBwG,aAAa,GAAG1G,MAAM,CAACA,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5C,IAAIwG,aAAa,KAAK,OAAO,IAAIA,aAAa,KAAK,SAAS,EAAE;QAC9DjG,MAAM,GAAGT,MAAM,CAACoC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG3B,MAAM;MACnC;MACA,OAAOA,MAAM;IACf;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAID,SAAAwB,2BAA2B3C,MAAM,EAAE;MACjC,IAAImE,IAAI;MACR,IAAI1D,MAAM,GAAG,EAAE;MACf,OAAOT,MAAM,CAACE,MAAM,EAAE;QACpBiE,IAAI,GAAGnE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACnB,IAAImE,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,SAAS,EAAE;QAC5C1D,MAAM,IAAIT,MAAM,CAAC4B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAC7B;MACA,OAAOnB,MAAM;IACf;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAED,SAAAsD,cAAczE,MAAM,EAAE;MACpB,IAAI0G,aAAa;MACjB,IAAIjG,MAAM,GAAG,EAAE;MACf,OAAOT,MAAM,CAACE,MAAM,EAAE;QACpBwG,aAAa,GAAG1G,MAAM,CAACA,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5C,IAAIwG,aAAa,KAAK,OAAO,EAAE;QAC/BjG,MAAM,GAAGT,MAAM,CAACoC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG3B,MAAM;MACnC;MACA,OAAOA,MAAM;IACf;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAED,SAAAqD,WAAWxE,MAAM,EAAE2G,IAAI,EAAE;MACvB,IAAIC,MAAM,GAAG,EAAE;MACf,KAAK,IAAI3G,CAAC,GAAG0G,IAAI,EAAE1G,CAAC,GAAGD,MAAM,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;QACzC2G,MAAM,IAAI5G,MAAM,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC;MACxB;MACAD,MAAM,CAAC6G,MAAM,CAACF,IAAI,EAAE3G,MAAM,CAACE,MAAM,GAAGyG,IAAI,CAAC;MACzC,OAAOC,MAAM;IACf;EAAC;IAAA1F,GAAA;IAAAC,KAAA,EAED,SAAAuE,cAAA,EAAgB;MACd,IAAItF,GAAG,GAAG,IAAI,CAACI,OAAO,CAACK,MAAM,CAACC,KAAK;MACnC,MAAM,IAAI,CAACR,KAAK,CAAC4C,KAAK,CAAC,gBAAgB,EAAE9C,GAAG,CAACY,IAAI,EAAEZ,GAAG,CAACW,MAAM,CAAC;IAChE;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAkF,gBAAgBJ,OAAO,EAAE;MACvB,MAAM,IAAI,CAAC3F,KAAK,CAAC4C,KAAK,CACpB,kBAAkB,EAClB;QAAEjC,MAAM,EAAEgF,OAAO,CAAC,CAAC;MAAE,CAAC,EACtB;QAAEhF,MAAM,EAAEgF,OAAO,CAAC,CAAC,CAAC,GAAG;MAAE,CAC3B,CAAC;IACH;EAAC;IAAA/E,GAAA;IAAAC,KAAA,EAED,SAAAqE,gBAAgBrF,KAAK,EAAE;MACrB,MAAM,IAAI,CAACG,KAAK,CAAC4C,KAAK,CACpB,cAAc,EACd;QAAEjC,MAAM,EAAEd,KAAK,CAAC,CAAC;MAAE,CAAC,EACpB;QAAEc,MAAM,EAAEd,KAAK,CAAC,CAAC,CAAC,GAAG;MAAE,CACzB,CAAC;IACH;EAAC;IAAAe,GAAA;IAAAC,KAAA,EAED,SAAA4C,YAAY/D,MAAM,EAAE;MAClB,MAAM,IAAI,CAACM,KAAK,CAAC4C,KAAK,CACpB,cAAc,EACd;QAAEjC,MAAM,EAAEjB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;MAAE,CAAC,EACxB;QAAEiB,MAAM,EAAEjB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACE;MAAO,CAC/C,CAAC;IACH;EAAC;IAAAgB,GAAA;IAAAC,KAAA,EAED,SAAAK,cAAcH,IAAI,EAAElB,KAAK,EAAE;MACzB,MAAM,IAAI,CAACG,KAAK,CAAC4C,KAAK,CACpB,sBAAsB,EACtB;QAAEjC,MAAM,EAAEd,KAAK,CAAC,CAAC;MAAE,CAAC,EACpB;QAAEc,MAAM,EAAEd,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,CAACD;MAAO,CACvC,CAAC;IACH;EAAC;EAAA,OAAAG,MAAA;AAAA;AAGHyG,MAAM,CAACC,OAAO,GAAG1G,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}